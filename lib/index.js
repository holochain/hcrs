const path = require('path')
const fs = require('fs')
const childProcess = require('child_process')

const modifyWarning = 'DO NOT MODIFY: generated by scaffold tool'

function validateScaffold (p) {
  const scaffold = JSON.parse(fs.readFileSync(p))

  if (typeof scaffold.name !== 'string') {
    throw new Error('no dna name')
  }
  // ... TODO - much more validation

  return scaffold
}

function genManifest (p, scaffold) {
  if (fs.existsSync(p)) {
    fs.unlinkSync(p)
  }
  fs.writeFileSync(p, JSON.stringify({
    '#notice': modifyWarning,
    name: scaffold.name,
    description: scaffold.description,
    version: scaffold.version,
    uuid: scaffold.uuid,
    dna_spec_version: '2.0',
    properties: scaffold.properties
  }, null, 2) + '\n')
}

function genDotBuild (p) {
  fs.writeFileSync(p, JSON.stringify({
    steps: {
      cargo: [
        'build',
        '--target', 'wasm32-unknown-unknown',
        '--release'
      ]
    },
    artifact: 'target/wasm32-unknown-unknown/release/code.wasm'
  }, null, 2) + '\n')
}

function genCargoToml (p) {
  fs.writeFileSync(p, `[package]
name = "code"
version = "0.0.1"
authors = ["scaffold tool"]

[dependencies]
hdk = { path = "../../../../holochain-rust/hdk-rust" }
holochain_core_types_derive = { path = "../../../../holochain-rust/core_types_derive" }
serde = "1"
serde_derive = "1"
serde_json = { version = "1", features = ["preserve_order"] }

[lib]
path = "src/lib.rs"
crate-type = ["cdylib"]
`)
}

function genLibRs (p) {
  fs.writeFileSync(p, `#![feature(try_from)]

#[macro_use]
extern crate hdk;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate serde_json;
#[macro_use]
extern crate holochain_core_types_derive;

pub mod zome_genesis;
pub mod zome_entry;
pub mod zome_fn;

pub mod zome_def;
`)
}

function genGenesisBlob (zomeDir, zomeName) {
  const genesisName = zomeName + '_genesis'
  const genesisRs = path.join(zomeDir, 'zome_genesis.rs')
  if (!fs.existsSync(genesisRs)) {
    fs.writeFileSync(genesisRs, `pub fn ${genesisName}() -> Result<(), String> {
    Ok(())
}
`)
  }
  return `genesis: || {
        zome_genesis::${genesisName}()
    }`
}

function genLink (zomeDir, entryName, entryData, outMods, link, outCode, type) {
  const linkMod = 'link_' + entryName + '_' + link.tag + '_' + type
  outMods.push('pub mod ' + linkMod + ';')
  const linkModRs = path.join(zomeDir, linkMod + '.rs')
  if (!fs.existsSync(linkModRs)) {
    fs.writeFileSync(linkModRs, `use hdk::holochain_core_types::{
    cas::content::Address,
};

pub fn validation_package() -> hdk::ValidationPackageDefinition {
    hdk::ValidationPackageDefinition::Entry
}

pub fn validation(_source: Address, _target: Address, _ctx: hdk::ValidationData) -> Result<(), String> {
    Ok(())
}
`)
  }

  outCode.push(`                ${type}!(
                    "%agent_id",
                    tag: "${link.tag}",
                    validation_package: || {
                        zome_entry::${linkMod}::validation_package()
                    },
                    validation: |source: Address, target: Address, ctx: hdk::ValidationData| {
                        zome_entry::${linkMod}::validation(source, target, ctx)
                    }
                ),`)
}

function genEntryLinks (zomeDir, entryName, entryData, outMods) {
  const outCode = ['links: [']

  for (let link of entryData.links_to) {
    genLink(zomeDir, entryName, entryData, outMods, link, outCode, 'to')
  }

  for (let link of entryData.linked_from) {
    genLink(zomeDir, entryName, entryData, outMods, link, outCode, 'from')
  }

  // last comma not cool?
  let last = outCode.pop()
  last = last.substr(0, last.length - 1)
  outCode.push(last)

  outCode.push('            ]')
  return outCode.join('\n')
}

function txSharing (s) {
  switch (s) {
    case 'public':
      return 'Public'
    default:
      throw new Error('unexpected sharing type: ' + s)
  }
}

function genEntryBlobs (zomeDir, zomeName, zomeData) {
  const outMods = ['// ' + modifyWarning + '\n']
  const outCode = ['entries: [']

  for (let entryName in zomeData.entry_types) {
    const entryData = zomeData.entry_types[entryName]
    const entryMod = 'entry_' + entryName
    outMods.push('pub mod ' + entryMod + ';')
    const entryModRs = path.join(zomeDir, entryMod + '.rs')
    if (!fs.existsSync(entryModRs)) {
      fs.writeFileSync(entryModRs, `use hdk::holochain_core_types::{
    error::HolochainError,
    json::JsonString,
};

#[derive(Serialize, Deserialize, Debug, DefaultJson)]
pub struct ${entryData.native_type} {
}

pub fn validation_package() -> hdk::ValidationPackageDefinition {
    hdk::ValidationPackageDefinition::Entry
}

pub fn validation(_entry: ${entryData.native_type}, _ctx: hdk::ValidationData) -> Result<(), String> {
    Ok(())
}
`)
    }

    const linkCode = genEntryLinks(zomeDir, entryName, entryData, outMods)

    outCode.push(`        entry!(
            name: "${entryName}",
            description: "${entryData.description}",
            sharing: Sharing::${txSharing(entryData.sharing)},
            native_type: zome_entry::${entryMod}::${entryData.native_type},
            validation_package: || {
                zome_entry::${entryMod}::validation_package()
            },
      validation: |entry: zome_entry::${entryMod}::${entryData.native_type}, ctx: hdk::ValidationData| {
                zome_entry::${entryMod}::validation(entry, ctx)
            },
            ${linkCode}
        ),`)
  }

  // last comma not cool?
  let last = outCode.pop()
  last = last.substr(0, last.length - 1)
  outCode.push(last)

  outCode.push('    ]')

  fs.writeFileSync(path.join(zomeDir, 'mod.rs'), outMods.join('\n') + '\n')

  return outCode.join('\n')
}

function txMembrane (s) {
  switch (s) {
    case 'public':
      return 'Public'
    default:
      throw new Error('unexpected membrane type: ' + s)
  }
}

function genInOut (io) {
  let out = ''
  for (let i = 0; i < io.length; ++i) {
    if (i > 0) {
      out += ', '
    }
    out += io[i].name + ': ' + io[i].type
  }
  return out
}

function genFunctionBlobs (zomeDir, zomeName, zomeData) {
  const outMods = ['// ' + modifyWarning + '\n']
  const outCode = ['functions: {']

  for (let capName in zomeData.capabilities) {
    const capData = zomeData.capabilities[capName]
    const membrane = capData.capability.membrane
    outCode.push('        ' + capName + ' (' + txMembrane(membrane) + ') {')

    for (let fn of capData.functions) {
      const fnMod = 'fn_' + capName + '_' + fn.name
      const fnHandle = 'handle_' + fn.name
      outMods.push('pub mod ' + fnMod + ';')

      const fnModRs = path.join(zomeDir, fnMod + '.rs')
      if (!fs.existsSync(fnModRs)) {
        fs.writeFileSync(fnModRs, `use hdk::{
    holochain_core_types::{
      json::JsonString,
    },
};

pub fn ${fnHandle}(${genInOut(fn.inputs)}) -> JsonString {
    "".into()
}
`)
      }

      outCode.push(`
            ${fn.name}: {
                inputs: |${genInOut(fn.inputs)}|,
                outputs: |${genInOut(fn.outputs)}|,
                handler: zome_fn::${fnMod}::${fnHandle}
            }`)
    }

    outCode.push('        }')
  }

  outCode.push('    }')

  fs.writeFileSync(path.join(zomeDir, 'mod.rs'), outMods.join('\n') + '\n')

  return outCode.join('\n')
}

function genZomeDefRs (zomeDir, zomeName, zomeData) {
  const entryDir = path.join(zomeDir, 'zome_entry')
  if (!fs.existsSync(entryDir)) {
    fs.mkdirSync(entryDir)
  }

  const fnDir = path.join(zomeDir, 'zome_fn')
  if (!fs.existsSync(fnDir)) {
    fs.mkdirSync(fnDir)
  }

  const gCode = genGenesisBlob(zomeDir, zomeName)
  const eCode = genEntryBlobs(entryDir, zomeName, zomeData)
  const fCode = genFunctionBlobs(fnDir, zomeName, zomeData)

  const zomeDefRs = path.join(zomeDir, 'zome_def.rs')
  if (fs.existsSync(zomeDefRs)) {
    fs.unlinkSync(zomeDefRs)
  }

  fs.writeFileSync(zomeDefRs, `// ${modifyWarning}

use hdk::holochain_core_types::{
    dna::zome::entry_types::Sharing,
    cas::content::Address,
};

use zome_genesis;
use zome_entry;
use zome_fn;

define_zome! {
    ${eCode}

    ${gCode}

    ${fCode}
}
`)
}

function genZome (zomeDir, zomeName, zomeData) {
  if (!fs.existsSync(zomeDir)) {
    fs.mkdirSync(zomeDir)
  }
  zomeDir = path.join(zomeDir, 'code')
  if (!fs.existsSync(zomeDir)) {
    fs.mkdirSync(zomeDir)
  }
  const dotBuild = path.join(zomeDir, '.build')
  if (!fs.existsSync(dotBuild)) {
    genDotBuild(dotBuild)
  }
  const cargoToml = path.join(zomeDir, 'Cargo.toml')
  if (!fs.existsSync(cargoToml)) {
    genCargoToml(cargoToml)
  }
  zomeDir = path.join(zomeDir, 'src')
  if (!fs.existsSync(zomeDir)) {
    fs.mkdirSync(zomeDir)
  }
  const libRs = path.join(zomeDir, 'lib.rs')
  if (!fs.existsSync(libRs)) {
    genLibRs(libRs)
  }

  genZomeDefRs(zomeDir, zomeName, zomeData)
}

function genZomes (p, scaffold) {
  if (!fs.existsSync(p)) {
    fs.mkdirSync(p)
  }
  for (let zomeName in scaffold.zomes) {
    const zomeData = scaffold.zomes[zomeName]
    genZome(path.join(p, zomeName), zomeName, zomeData)
  }
}

exports.generate = async function generate () {
  const pathScaffold = path.resolve('scaffold.json')
  const pathApp = path.resolve('app')
  const pathZomes = path.join(pathApp, 'zomes')
  const pathManifest = path.join(pathApp, 'manifest.json')

  if (!fs.existsSync(pathScaffold)) {
    throw new Error('this does not look like a holochain-rust scaffold directory')
  }

  console.log('Generating app in ' + pathApp)

  if (!fs.existsSync(pathApp)) {
    fs.mkdirSync(pathApp)
  }

  const scaffold = validateScaffold(pathScaffold)

  genManifest(pathManifest, scaffold)
  genZomes(pathZomes, scaffold)

  return scaffold.name
}

exports.build = async function build () {
  const projectName = await exports.generate()

  const pathApp = path.resolve('app')

  const hcVer = childProcess.execSync('hc --version').toString()
  if (hcVer !== 'hc 0.0.2\n') {
    throw new Error('hc v0.0.2 not found, is it in your path?')
  }

  const rustDir = path.resolve('holochain-rust')
  if (!fs.existsSync(rustDir) || !fs.existsSync(path.join(rustDir, 'hdk-rust'))) {
    throw new Error('holochain-rust directory not found. Please check it out or symlink it here.')
  }

  console.log('Building app in ' + pathApp)

  const proc = childProcess.spawn('hc', ['package', '--output', '../' + projectName + '.hcpkg', '--strip-meta'], {
    cwd: pathApp,
    stdio: 'inherit'
  })

  return new Promise((resolve, reject) => {
    proc.on('close', (code) => {
      if (code === 0) {
        resolve()
      } else {
        reject(new Error('hc exited with code ' + code))
      }
    })
  })
}
